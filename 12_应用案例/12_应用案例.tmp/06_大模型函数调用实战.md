# 实战案例：大模型函数调用(Function Calling)实战

> 本文将带您深入理解大模型的函数调用机制，从理论到实践，构建能够调用外部工具的智能应用。

---

## 📋 案例概述

### 场景
构建一个智能助手，能够：
- 理解用户意图并自动选择合适的工具
- 调用外部 API 获取实时信息
- 执行计算、查询数据库等操作
- 实现真正有用的 AI 辅助能力

### 技术栈
- **大模型**：GPT-4o / Claude 3.5 / 通义千问
- **开发框架**：LangChain / OpenAI SDK
- **工具**：天气 API、搜索 API、计算器等

### 学习目标
1. 理解 Function Calling 的工作原理
2. 掌握函数定义和调用的完整流程
3. 能够构建多工具协同的智能助手
4. 了解常见问题和最佳实践

---

## 🏗️ 案例项目结构

```
function-calling-project/
├── tools/
│   ├── __init__.py
│   ├── weather.py         # 天气查询工具
│   ├── search.py          # 搜索工具
│   └── calculator.py     # 计算器工具
├── agent/
│   ├── __init__.py
│   └── tool_agent.py      # 智能体实现
├── data/
│   └── function_schemas.json  # 函数定义
├── main.py                # 主程序
├── requirements.txt       # 依赖
└── .env                   # API密钥
```

---

## 🚀 第一步：理解 Function Calling

### 1.1 什么是 Function Calling？

Function Calling（函数调用）是 LLM 的重要能力，允许模型：
- 识别用户请求中需要调用函数的部分
- 解析并提取函数所需的参数
- 根据函数返回结果生成最终回答

### 1.2 工作流程

```
用户请求 → LLM 判断是否需要调用函数 → 提取参数 → 调用函数 → 返回结果 → LLM 生成最终回答
```

### 1.3 与传统 API 调用的区别

| 特性 | 传统 API 调用 | Function Calling |
|------|--------------|------------------|
| 参数解析 | 手动解析 | LLM 自动解析 |
| 调用时机 | 手动判断 | LLM 自动判断 |
| 错误处理 | 手动处理 | LLM 辅助处理 |
| 自然语言 | 不支持 | 完全支持 |

---

## 📝 第二步：定义工具函数

### 2.1 天气查询工具

创建 `tools/weather.py`：

```python
"""天气查询工具"""
import requests
from typing import Optional

def get_weather(city: str, units: str = "celsius") -> str:
    """
    查询指定城市的天气情况
    
    Args:
        city: 城市名称，如 "北京"、"Shanghai"
        units: 温度单位，"celsius" 或 "fahrenheit"
    
    Returns:
        天气信息字符串
    """
    # 这里使用免费天气API（实际项目中替换为真实API）
    API_KEY = "your_weather_api_key"
    base_url = "https://api.openweathermap.org/data/2.5/weather"
    
    params = {
        "q": city,
        "appid": API_KEY,
        "units": "metric" if units == "celsius" else "imperial"
    }
    
    try:
        response = requests.get(base_url, params=params, timeout=10)
        data = response.json()
        
        if data.get("cod") == 200:
            weather = data["weather"][0]["description"]
            temp = data["main"]["temp"]
            humidity = data["main"]["humidity"]
            wind = data["wind"]["speed"]
            
            return f"{city}当前天气：{weather}，温度：{temp}°C，湿度：{humidity}%，风速：{wind}m/s"
        else:
            return f"无法获取{city}的天气信息：{data.get('message', '未知错误')}"
    except Exception as e:
        return f"查询天气失败：{str(e)}"
```

### 2.2 搜索工具

创建 `tools/search.py`：

```python
"""网络搜索工具"""
import requests
from typing import List, Dict

def search_web(query: str, max_results: int = 5) -> str:
    """
    搜索互联网获取相关信息
    
    Args:
        query: 搜索关键词
        max_results: 返回结果数量，默认5条
    
    Returns:
        格式化后的搜索结果
    """
    # 使用 DuckDuckGo 免费搜索API
    url = "https://api.duckduckgo.com/"
    params = {
        "q": query,
        "format": "json",
        "no_html": 1,
        "skip_disambig": 1
    }
    
    try:
        response = requests.get(url, params=params, timeout=10)
        data = response.json()
        
        results = []
        for i, item in enumerate(data.get("RelatedTopics", [])[:max_results]):
            if "Text" in item:
                results.append(f"{i+1}. {item['Text']}")
        
        if results:
            return "搜索结果：\n" + "\n".join(results)
        else:
            return f"未找到与'{query}'相关的搜索结果"
    except Exception as e:
        return f"搜索失败：{str(e)}"
```

### 2.3 计算器工具

创建 `tools/calculator.py`：

```python
"""数学计算工具"""
import math
import re
from typing import Union

def calculate(expression: str) -> str:
    """
    执行数学计算
    
    Args:
        expression: 数学表达式，如 "sqrt(16) + 2^3"
    
    Returns:
        计算结果
    """
    # 安全评估：只允许特定的数学函数和运算符
    allowed_names = {
        "abs": abs,
        "max": max,
        "min": min,
        "pow": pow,
        "round": round,
        "sqrt": math.sqrt,
        "sin": math.sin,
        "cos": math.cos,
        "tan": math.tan,
        "log": math.log,
        "log10": math.log10,
        "pi": math.pi,
        "e": math.e,
    }
    
    # 替换常见的数学写法
    expression = expression.replace("^", "**")
    expression = expression.replace("×", "*")
    expression = expression.replace("÷", "/")
    
    try:
        # 使用 eval（生产环境建议用安全的解析器）
        result = eval(expression, {"__builtins__": {}}, allowed_names)
        return f"计算结果：{expression} = {result}"
    except Exception as e:
        return f"计算错误：{str(e)}"
```

### 2.4 工具注册与管理

创建 `tools/__init__.py`：

```python
"""工具模块"""
from .weather import get_weather
from .search import search_web
from .calculator import calculate

# 导出所有工具函数
__all__ = ["get_weather", "search_web", "calculate"]

# 工具函数到工具描述的映射
TOOL_DESCRIPTIONS = {
    "get_weather": {
        "name": "get_weather",
        "description": "查询指定城市的天气情况。适用于用户询问特定城市天气、是否需要带伞、穿什么衣服等场景。",
        "parameters": {
            "type": "object",
            "properties": {
                "city": {
                    "type": "string",
                    "description": "城市名称，如 '北京'、'Shanghai'、'Tokyo'"
                },
                "units": {
                    "type": "string",
                    "enum": ["celsius", "fahrenheit"],
                    "description": "温度单位，默认 celsius（摄氏度）"
                }
            },
            "required": ["city"]
        }
    },
    "search_web": {
        "name": "search_web",
        "description": "搜索互联网获取相关信息。适用于用户询问实时信息、新闻、百科知识等需要最新数据的场景。",
        "parameters": {
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": "搜索关键词"
                },
                "max_results": {
                    "type": "integer",
                    "description": "返回结果数量，默认5条"
                }
            },
            "required": ["query"]
        }
    },
    "calculate": {
        "name": "calculate",
        "description": "执行数学计算。适用于用户询问数学问题、需要进行数值计算的场景。支持基本运算符和数学函数。",
        "parameters": {
            "type": "object",
            "properties": {
                "expression": {
                    "type": "string",
                    "description": "数学表达式，如 '2+3*4'、'sqrt(16)'、'2^10'"
                }
            },
            "required": ["expression"]
        }
    }
}
```

---

## 🔧 第三步：实现 Function Calling

### 3.1 OpenAI API 实现

创建 `main.py`：

```python
"""使用 OpenAI API 实现 Function Calling"""
import os
import json
from openai import OpenAI
from tools import get_weather, search_web, calculate, TOOL_DESCRIPTIONS

# 初始化客户端
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# 将工具描述转换为 OpenAI 格式
def get_tools_schema():
    """获取 OpenAI 格式的工具定义"""
    return [
        {
            "type": "function",
            "function": {
                "name": name,
                "description": info["description"],
                "parameters": info["parameters"]
            }
        }
        for name, info in TOOL_DESCRIPTIONS.items()
    ]

# 工具函数映射
TOOL_FUNCTIONS = {
    "get_weather": get_weather,
    "search_web": search_web,
    "calculate": calculate
}

def call_function(name: str, arguments: dict) -> str:
    """调用对应的工具函数"""
    func = TOOL_FUNCTIONS.get(name)
    if func:
        return func(**arguments)
    return f"未找到函数：{name}"

def chat_with_function_calling(messages: list, tools: list = None) -> dict:
    """带有函数调用能力的聊天"""
    if tools is None:
        tools = get_tools_schema()
    
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=messages,
        tools=tools,
        tool_choice="auto"
    )
    
    return response

def main():
    # 对话历史
    messages = [
        {"role": "system", "content": "你是一个智能助手，可以帮助用户查询天气、搜索信息、执行计算等。请用中文回复。"}
    ]
    
    print("=" * 50)
    print("🧠 Function Calling 智能助手")
    print("=" * 50)
    print("我可以帮你：查询天气 | 搜索信息 | 数学计算")
    print("输入 'quit' 退出")
    print("=" * 50)
    
    while True:
        user_input = input("\n👤 你: ").strip()
        
        if user_input.lower() in ["quit", "退出", "exit"]:
            print("👋 再见！")
            break
        
        if not user_input:
            continue
        
        messages.append({"role": "user", "content": user_input})
        
        # 第一次调用：让模型决定是否需要调用函数
        response = chat_with_function_calling(messages)
        
        # 检查是否有函数调用
        if response.choices[0].message.tool_calls:
            # 处理函数调用
            for tool_call in response.choices[0].message.tool_calls:
                func_name = tool_call.function.name
                func_args = json.loads(tool_call.function.arguments)
                
                print(f"\n🔧 调用函数: {func_name}")
                print(f"📝 参数: {func_args}")
                
                # 调用函数
                result = call_function(func_name, func_args)
                print(f"📤 返回结果: {result}")
                
                # 将函数结果添加到对话
                messages.append({
                    "role": "assistant",
                    "tool_calls": [
                        {
                            "id": tool_call.id,
                            "type": "function",
                            "function": {
                                "name": func_name,
                                "arguments": tool_call.function.arguments
                            }
                        }
                    ]
                })
                messages.append({
                    "role": "tool",
                    "tool_call_id": tool_call.id,
                    "content": result
                })
            
            # 第二次调用：获取最终回答
            final_response = client.chat.completions.create(
                model="gpt-4o",
                messages=messages
            )
            
            final_content = final_response.choices[0].message.content
            print(f"\n🤖 助手: {final_content}")
            messages.append({"role": "assistant", "content": final_content})
        else:
            # 直接回答
            content = response.choices[0].message.content
            print(f"\n🤖 助手: {content}")
            messages.append({"role": "assistant", "content": content})

if __name__ == "__main__":
    main()
```

### 3.2 LangChain 实现

创建 `agent/tool_agent.py`：

```python
"""使用 LangChain 实现 Function Calling Agent"""
from langchain_openai import ChatOpenAI
from langchain_core.tools import tool
from langchain.agents import AgentExecutor, create_openai_functions_agent
from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder

# 使用 LangChain 的 @tool 装饰器定义工具
@tool
def get_weather(city: str, units: str = "celsius") -> str:
    """查询指定城市的天气情况"""
    # 这里简化处理，实际项目中调用真实API
    weathers = {
        "北京": "晴，15°C",
        "上海": "多云，18°C",
        "深圳": "晴，22°C",
        "广州": "阴，20°C"
    }
    return weathers.get(city, f"暂无{city}的天气数据")

@tool
def search_web(query: str) -> str:
    """搜索互联网获取相关信息"""
    # 简化实现
    return f"搜索'{query}'的结果：这是模拟的搜索结果..."

@tool
def calculate(expression: str) -> str:
    """执行数学计算"""
    try:
        result = eval(expression, {"__builtins__": {}}, {
            "abs": abs, "max": max, "min": min, 
            "pow": pow, "sqrt": __import__("math").sqrt,
            "pi": __import__("math").pi
        })
        return f"{expression} = {result}"
    except Exception as e:
        return f"计算错误：{str(e)}"

# 创建工具列表
tools = [get_weather, search_web, calculate]

# 创建模型
llm = ChatOpenAI(model="gpt-4o", temperature=0)

# 创建提示模板
prompt = ChatPromptTemplate.from_messages([
    ("system", "你是一个智能助手，可以调用工具来帮助用户。"),
    ("user", "{input}"),
    MessagesPlaceholder(variable_name="agent_scratchpad", optional=True)
])

# 创建 Agent
agent = create_openai_functions_agent(llm, tools, prompt)

# 创建 Agent 执行器
agent_executor = AgentExecutor(
    agent=agent, 
    tools=tools, 
    verbose=True,
    max_iterations=10
)

def run_agent(query: str) -> str:
    """运行 Agent 处理用户查询"""
    result = agent_executor.invoke({"input": query})
    return result["output"]

# 测试
if __name__ == "__main__":
    test_queries = [
        "北京今天天气怎么样？",
        "搜索一下人工智能的最新发展",
        "计算 2 的 10 次方是多少",
        "帮我查一下上海的天气，然后搜索上海旅游攻略"
    ]
    
    for query in test_queries:
        print(f"\n{'='*50}")
        print(f"问题: {query}")
        print(f"回答: {run_agent(query)}")
```

---

## 🔄 第四步：多工具协同

### 4.1 顺序调用

处理需要多个工具依次调用的场景：

```python
"""顺序调用多个工具"""
def sequential_tools_example(query: str) -> str:
    """处理需要多个工具的查询"""
    
    # 场景：用户问天气，然后问适合做什么
    if "天气" in query:
        # 1. 先查询天气
        weather_result = get_weather(city="北京")
        
        # 2. 根据天气情况给出建议
        if "晴" in weather_result:
            return f"{weather_result}\n\n建议：适合外出活动，可以去公园散步。"
        elif "雨" in weather_result:
            return f"{weather_result}\n\n建议：建议室内活动，可以去博物馆或咖啡馆。"
        else:
            return weather_result
    
    return "无法处理该查询"
```

### 4.2 并行调用

同时调用多个独立的工具：

```python
"""并行调用多个工具"""
import concurrent.futures

def parallel_tools_example(cities: list) -> dict:
    """并行查询多个城市的天气"""
    
    with concurrent.futures.ThreadPoolExecutor() as executor:
        # 并行查询所有城市天气
        futures = {city: executor.submit(get_weather, city) for city in cities}
        
        results = {}
        for city, future in futures.items():
            results[city] = future.result()
    
    return results

# 使用示例
if __name__ == "__main__":
    cities = ["北京", "上海", "深圳", "广州"]
    results = parallel_tools_example(cities)
    
    for city, weather in results.items():
        print(f"{city}: {weather}")
```

---

## ⚠️ 第五步：最佳实践与注意事项

### 5.1 函数定义最佳实践

```python
# ✅ 好的函数定义
def get_stock_price(symbol: str) -> float:
    """
    获取股票当前价格
    
    Args:
        symbol: 股票代码，如 "AAPL"、 "TSLA"
    
    Returns:
        股票当前价格
    
    Example:
        >>> get_stock_price("AAPL")
        178.52
    """
    pass

# ❌ 差的函数定义
def get_price(x):  # 缺少类型提示和描述
    pass
```

### 5.2 错误处理

```python
"""完善的错误处理"""
def safe_function_call(func_name: str, args: dict) -> str:
    """安全的函数调用包装器"""
    try:
        func = TOOL_FUNCTIONS.get(func_name)
        if not func:
            return f"错误：未找到函数 {func_name}"
        
        result = func(**args)
        return str(result)
    
    except TypeError as e:
        return f"参数错误：{str(e)}"
    except ValueError as e:
        return f"值错误：{str(e)}"
    except Exception as e:
        return f"未知错误：{str(e)}"
```

### 5.3 安全性考虑

```python
"""安全加固措施"""
import ast
import re

def validate_function_args(func_name: str, args: dict) -> bool:
    """验证函数参数的安全性"""
    
    # 白名单验证
    allowed_functions = {"get_weather", "search_web", "calculate"}
    
    if func_name not in allowed_functions:
        return False
    
    # 参数类型验证
    if func_name == "calculate":
        # 防止危险的数学表达式
        dangerous_patterns = [r"__", r"import", r"exec", r"eval"]
        expression = args.get("expression", "")
        
        for pattern in dangerous_patterns:
            if re.search(pattern, expression, re.IGNORECASE):
                return False
    
    return True
```

---

## 🧪 第六步：完整示例

### 6.1 主程序

创建完整的 `main.py`：

```python
"""完整的 Function Calling 示例"""
import os
import json
from openai import OpenAI

# 导入工具
from tools import get_weather, search_web, calculate, TOOL_DESCRIPTIONS

# 初始化
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# 工具映射
TOOL_FUNCTIONS = {
    "get_weather": get_weather,
    "search_web": search_web,
    "calculate": calculate
}

def get_tools():
    """获取工具定义"""
    return [
        {
            "type": "function",
            "function": {
                "name": name,
                "description": info["description"],
                "parameters": info["parameters"]
            }
        }
        for name, info in TOOL_DESCRIPTIONS.items()
    ]

def process_query(query: str, history: list) -> str:
    """处理用户查询"""
    
    # 添加用户消息
    history.append({"role": "user", "content": query})
    
    # 第一次调用
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=history,
        tools=get_tools(),
        tool_choice="auto"
    )
    
    message = response.choices[0].message
    
    # 检查工具调用
    if message.tool_calls:
        for tool_call in message.tool_calls:
            func_name = tool_call.function.name
            func_args = json.loads(tool_call.function.arguments)
            
            print(f"🔧 调用工具: {func_name}")
            print(f"📝 参数: {func_args}")
            
            # 调用工具
            result = TOOL_FUNCTIONS[func_name](**func_args)
            print(f"📤 结果: {result}")
            
            # 添加助手的消息（包含工具调用）
            history.append({
                "role": "assistant",
                "content": None,
                "tool_calls": [
                    {
                        "id": tool_call.id,
                        "type": "function",
                        "function": {
                            "name": func_name,
                            "arguments": tool_call.function.arguments
                        }
                    }
                ]
            })
            
            # 添加工具返回结果
            history.append({
                "role": "tool",
                "tool_call_id": tool_call.id,
                "content": result
            })
        
        # 第二次调用：获取最终回答
        final_response = client.chat.completions.create(
            model="gpt-4o",
            messages=history
        )
        
        final_message = final_response.choices[0].message.content
        history.append({"role": "assistant", "content": final_message})
        
        return final_message
    
    else:
        # 直接回答
        content = message.content
        history.append({"role": "assistant", "content": content})
        return content

def main():
    """主函数"""
    print("=" * 60)
    print("🧠 Function Calling 智能助手")
    print("=" * 60)
    print("功能：天气查询 | 网络搜索 | 数学计算")
    print("输入 'quit' 退出")
    print("=" * 60)
    
    history = [
        {"role": "system", "content": "你是一个有用的AI助手，可以调用工具来帮助用户。请用中文回答。"}
    ]
    
    while True:
        try:
            query = input("\n👤 你: ").strip()
            
            if query.lower() in ["quit", "exit", "退出"]:
                print("👋 再见！")
                break
            
            if not query:
                continue
            
            response = process_query(query, history)
            print(f"\n🤖 助手: {response}")
            
        except KeyboardInterrupt:
            print("\n👋 再见！")
            break
        except Exception as e:
            print(f"❌ 错误: {str(e)}")

if __name__ == "__main__":
    main()
```

### 6.2 requirements.txt

```
openai>=1.0.0
requests>=2.31.0
python-dotenv>=1.0.0
```

---

## 📊 效果测试

### 测试用例

| 输入 | 调用函数 | 参数 | 预期回答 |
|------|---------|------|---------|
| 北京今天天气怎么样？ | get_weather | {"city": "北京"} | 天气信息+建议 |
| 搜索 AI 最新新闻 | search_web | {"query": "AI 最新新闻"} | 搜索结果 |
| 计算 2 的 10 次方 | calculate | {"expression": "2**10"} | 1024 |
| 上海天气如何？适合旅游吗？ | get_weather + 生成建议 | {"city": "上海"} | 天气+旅游建议 |

---

## 📚 扩展学习

### 进阶主题
1. **Toolformer**：模型自主学习调用工具
2. **ReAct**：推理+行动协同
3. **Agent 架构**：Plan-Execute、React 等模式
4. **多模态函数调用**：处理图像、音频输入

### 相关资源
- [OpenAI Function Calling 文档](https://platform.openai.com/docs/guides/function-calling)
- [LangChain Tools](https://python.langchain.com/docs/modules/agents/tools/)
- [Claude Function Calling](https://docs.anthropic.com/en/docs/build-with-claude/function-calling)

---

## ✅ 总结

本文介绍了大模型 Function Calling 的完整实践：

1. **理论基础**：理解 Function Calling 的工作原理
2. **工具定义**：如何定义清晰的函数签名和描述
3. **API 实现**：使用 OpenAI API 实现函数调用
4. **框架实现**：使用 LangChain 简化开发
5. **最佳实践**：错误处理、安全性、性能优化

通过 Function Calling，LLM 可以与外部系统交互，实现更强大的智能应用。

---

*💡 提示：实际生产环境中，建议添加更完善的错误处理、日志记录和监控机制。*
